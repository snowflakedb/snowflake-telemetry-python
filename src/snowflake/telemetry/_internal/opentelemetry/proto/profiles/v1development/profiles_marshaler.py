# Generated by the protoc compiler with a custom plugin. DO NOT EDIT!
# sources: opentelemetry/proto/profiles/v1development/profiles.proto
#
# Copyright (c) 2012-2024 Snowflake Inc. All rights reserved.
#
# Copyright 2023, OpenTelemetry Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file includes work covered by the following copyright and permission notices:
#
# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file has been generated from the original proto schema at
#
#     https://github.com/open-telemetry/opentelemetry-proto
#
# using a custom protoc compiler plugin by Snowflake Inc.

from __future__ import annotations

import struct
from typing import List

from snowflake.telemetry._internal.opentelemetry.proto.common.v1.common_marshaler import *
from snowflake.telemetry._internal.opentelemetry.proto.resource.v1.resource_marshaler import *
from snowflake.telemetry._internal.serialize import (
    Enum,
    MessageMarshaler,
    Varint,
)


class AggregationTemporality(Enum):
    AGGREGATION_TEMPORALITY_UNSPECIFIED = 0
    AGGREGATION_TEMPORALITY_DELTA = 1
    AGGREGATION_TEMPORALITY_CUMULATIVE = 2


class ProfilesDictionary(MessageMarshaler):
    @property
    def mapping_table(self) -> List[Mapping]:
        if self._mapping_table is None:
            self._mapping_table = list()
        return self._mapping_table

    @property
    def location_table(self) -> List[Location]:
        if self._location_table is None:
            self._location_table = list()
        return self._location_table

    @property
    def function_table(self) -> List[Function]:
        if self._function_table is None:
            self._function_table = list()
        return self._function_table

    @property
    def link_table(self) -> List[Link]:
        if self._link_table is None:
            self._link_table = list()
        return self._link_table

    @property
    def string_table(self) -> List[str]:
        if self._string_table is None:
            self._string_table = list()
        return self._string_table

    @property
    def attribute_table(self) -> List[KeyValue]:
        if self._attribute_table is None:
            self._attribute_table = list()
        return self._attribute_table

    @property
    def attribute_units(self) -> List[AttributeUnit]:
        if self._attribute_units is None:
            self._attribute_units = list()
        return self._attribute_units

    def __init__(
        self,
        mapping_table: List[Mapping] = None,
        location_table: List[Location] = None,
        function_table: List[Function] = None,
        link_table: List[Link] = None,
        string_table: List[str] = None,
        attribute_table: List[KeyValue] = None,
        attribute_units: List[AttributeUnit] = None,
    ):
        self._mapping_table: List[Mapping] = mapping_table
        self._location_table: List[Location] = location_table
        self._function_table: List[Function] = function_table
        self._link_table: List[Link] = link_table
        self._string_table: List[str] = string_table
        self._attribute_table: List[KeyValue] = attribute_table
        self._attribute_units: List[AttributeUnit] = attribute_units

    def calculate_size(self) -> int:
        size = 0
        if self._mapping_table:
            size += sum(
                message._get_size()
                + len(b"\n")
                + Varint.size_varint_u32(message._get_size())
                for message in self._mapping_table
            )
        if self._location_table:
            size += sum(
                message._get_size()
                + len(b"\x12")
                + Varint.size_varint_u32(message._get_size())
                for message in self._location_table
            )
        if self._function_table:
            size += sum(
                message._get_size()
                + len(b"\x1a")
                + Varint.size_varint_u32(message._get_size())
                for message in self._function_table
            )
        if self._link_table:
            size += sum(
                message._get_size()
                + len(b'"')
                + Varint.size_varint_u32(message._get_size())
                for message in self._link_table
            )
        if self._string_table:
            size = 0
            for s in self._string_table:
                string_data = s.encode("utf-8")
                size += (
                    len(b"*")
                    + Varint.size_varint_u32(len(string_data))
                    + len(string_data)
                )
            size += size
        if self._attribute_table:
            size += sum(
                message._get_size()
                + len(b"2")
                + Varint.size_varint_u32(message._get_size())
                for message in self._attribute_table
            )
        if self._attribute_units:
            size += sum(
                message._get_size()
                + len(b":")
                + Varint.size_varint_u32(message._get_size())
                for message in self._attribute_units
            )
        return size

    def write_to(self, out: bytearray) -> None:
        if self._mapping_table:
            for v in self._mapping_table:
                out += b"\n"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._location_table:
            for v in self._location_table:
                out += b"\x12"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._function_table:
            for v in self._function_table:
                out += b"\x1a"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._link_table:
            for v in self._link_table:
                out += b'"'
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._string_table:
            for v in self._string_table:
                out += b"*"
                data = v.encode("utf-8")
                Varint.write_varint_u32(out, len(data))
                out += data
        if self._attribute_table:
            for v in self._attribute_table:
                out += b"2"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._attribute_units:
            for v in self._attribute_units:
                out += b":"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)


class ProfilesData(MessageMarshaler):
    @property
    def resource_profiles(self) -> List[ResourceProfiles]:
        if self._resource_profiles is None:
            self._resource_profiles = list()
        return self._resource_profiles

    @property
    def dictionary(self) -> ProfilesDictionary:
        if self._dictionary is None:
            self._dictionary = ProfilesDictionary()
        return self._dictionary

    def __init__(
        self,
        resource_profiles: List[ResourceProfiles] = None,
        dictionary: ProfilesDictionary = None,
    ):
        self._resource_profiles: List[ResourceProfiles] = resource_profiles
        self._dictionary: ProfilesDictionary = dictionary

    def calculate_size(self) -> int:
        size = 0
        if self._resource_profiles:
            size += sum(
                message._get_size()
                + len(b"\n")
                + Varint.size_varint_u32(message._get_size())
                for message in self._resource_profiles
            )
        if self._dictionary is not None:
            size += (
                len(b"\x12")
                + Varint.size_varint_u32(self._dictionary._get_size())
                + self._dictionary._get_size()
            )
        return size

    def write_to(self, out: bytearray) -> None:
        if self._resource_profiles:
            for v in self._resource_profiles:
                out += b"\n"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._dictionary is not None:
            out += b"\x12"
            Varint.write_varint_u32(out, self._dictionary._get_size())
            self._dictionary.write_to(out)


class ResourceProfiles(MessageMarshaler):
    @property
    def resource(self) -> Resource:
        if self._resource is None:
            self._resource = Resource()
        return self._resource

    @property
    def scope_profiles(self) -> List[ScopeProfiles]:
        if self._scope_profiles is None:
            self._scope_profiles = list()
        return self._scope_profiles

    schema_url: str

    def __init__(
        self,
        resource: Resource = None,
        scope_profiles: List[ScopeProfiles] = None,
        schema_url: str = "",
    ):
        self._resource: Resource = resource
        self._scope_profiles: List[ScopeProfiles] = scope_profiles
        self.schema_url: str = schema_url

    def calculate_size(self) -> int:
        size = 0
        if self._resource is not None:
            size += (
                len(b"\n")
                + Varint.size_varint_u32(self._resource._get_size())
                + self._resource._get_size()
            )
        if self._scope_profiles:
            size += sum(
                message._get_size()
                + len(b"\x12")
                + Varint.size_varint_u32(message._get_size())
                for message in self._scope_profiles
            )
        if self.schema_url:
            v = self.schema_url.encode("utf-8")
            size += len(b"\x1a") + Varint.size_varint_u32(len(v)) + len(v)
        return size

    def write_to(self, out: bytearray) -> None:
        if self._resource is not None:
            out += b"\n"
            Varint.write_varint_u32(out, self._resource._get_size())
            self._resource.write_to(out)
        if self._scope_profiles:
            for v in self._scope_profiles:
                out += b"\x12"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self.schema_url:
            v = self.schema_url.encode("utf-8")
            out += b"\x1a"
            Varint.write_varint_u32(out, len(v))
            out += v


class ScopeProfiles(MessageMarshaler):
    @property
    def scope(self) -> InstrumentationScope:
        if self._scope is None:
            self._scope = InstrumentationScope()
        return self._scope

    @property
    def profiles(self) -> List[Profile]:
        if self._profiles is None:
            self._profiles = list()
        return self._profiles

    schema_url: str

    def __init__(
        self,
        scope: InstrumentationScope = None,
        profiles: List[Profile] = None,
        schema_url: str = "",
    ):
        self._scope: InstrumentationScope = scope
        self._profiles: List[Profile] = profiles
        self.schema_url: str = schema_url

    def calculate_size(self) -> int:
        size = 0
        if self._scope is not None:
            size += (
                len(b"\n")
                + Varint.size_varint_u32(self._scope._get_size())
                + self._scope._get_size()
            )
        if self._profiles:
            size += sum(
                message._get_size()
                + len(b"\x12")
                + Varint.size_varint_u32(message._get_size())
                for message in self._profiles
            )
        if self.schema_url:
            v = self.schema_url.encode("utf-8")
            size += len(b"\x1a") + Varint.size_varint_u32(len(v)) + len(v)
        return size

    def write_to(self, out: bytearray) -> None:
        if self._scope is not None:
            out += b"\n"
            Varint.write_varint_u32(out, self._scope._get_size())
            self._scope.write_to(out)
        if self._profiles:
            for v in self._profiles:
                out += b"\x12"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self.schema_url:
            v = self.schema_url.encode("utf-8")
            out += b"\x1a"
            Varint.write_varint_u32(out, len(v))
            out += v


class Profile(MessageMarshaler):
    @property
    def sample_type(self) -> List[ValueType]:
        if self._sample_type is None:
            self._sample_type = list()
        return self._sample_type

    @property
    def sample(self) -> List[Sample]:
        if self._sample is None:
            self._sample = list()
        return self._sample

    @property
    def location_indices(self) -> List[int]:
        if self._location_indices is None:
            self._location_indices = list()
        return self._location_indices

    time_nanos: int
    duration_nanos: int

    @property
    def period_type(self) -> ValueType:
        if self._period_type is None:
            self._period_type = ValueType()
        return self._period_type

    period: int

    @property
    def comment_strindices(self) -> List[int]:
        if self._comment_strindices is None:
            self._comment_strindices = list()
        return self._comment_strindices

    default_sample_type_index: int
    profile_id: bytes
    dropped_attributes_count: int
    original_payload_format: str
    original_payload: bytes

    @property
    def attribute_indices(self) -> List[int]:
        if self._attribute_indices is None:
            self._attribute_indices = list()
        return self._attribute_indices

    def __init__(
        self,
        sample_type: List[ValueType] = None,
        sample: List[Sample] = None,
        location_indices: List[int] = None,
        time_nanos: int = 0,
        duration_nanos: int = 0,
        period_type: ValueType = None,
        period: int = 0,
        comment_strindices: List[int] = None,
        default_sample_type_index: int = 0,
        profile_id: bytes = b"",
        dropped_attributes_count: int = 0,
        original_payload_format: str = "",
        original_payload: bytes = b"",
        attribute_indices: List[int] = None,
    ):
        self._sample_type: List[ValueType] = sample_type
        self._sample: List[Sample] = sample
        self._location_indices: List[int] = location_indices
        self.time_nanos: int = time_nanos
        self.duration_nanos: int = duration_nanos
        self._period_type: ValueType = period_type
        self.period: int = period
        self._comment_strindices: List[int] = comment_strindices
        self.default_sample_type_index: int = default_sample_type_index
        self.profile_id: bytes = profile_id
        self.dropped_attributes_count: int = dropped_attributes_count
        self.original_payload_format: str = original_payload_format
        self.original_payload: bytes = original_payload
        self._attribute_indices: List[int] = attribute_indices

    def calculate_size(self) -> int:
        size = 0
        if self._sample_type:
            size += sum(
                message._get_size()
                + len(b"\n")
                + Varint.size_varint_u32(message._get_size())
                for message in self._sample_type
            )
        if self._sample:
            size += sum(
                message._get_size()
                + len(b"\x12")
                + Varint.size_varint_u32(message._get_size())
                for message in self._sample
            )
        if self._location_indices:
            s = sum(Varint.size_varint_i32(int32) for int32 in self._location_indices)
            self.marshaler_cache[b"\x1a"] = s
            size += len(b"\x1a") + s + Varint.size_varint_u32(s)
        if self.time_nanos:
            size += len(b" ") + Varint.size_varint_i64(self.time_nanos)
        if self.duration_nanos:
            size += len(b"(") + Varint.size_varint_i64(self.duration_nanos)
        if self._period_type is not None:
            size += (
                len(b"2")
                + Varint.size_varint_u32(self._period_type._get_size())
                + self._period_type._get_size()
            )
        if self.period:
            size += len(b"8") + Varint.size_varint_i64(self.period)
        if self._comment_strindices:
            s = sum(Varint.size_varint_i32(int32) for int32 in self._comment_strindices)
            self.marshaler_cache[b"B"] = s
            size += len(b"B") + s + Varint.size_varint_u32(s)
        if self.default_sample_type_index:
            size += len(b"H") + Varint.size_varint_i32(self.default_sample_type_index)
        if self.profile_id:
            size += (
                len(b"R")
                + Varint.size_varint_u32(len(self.profile_id))
                + len(self.profile_id)
            )
        if self.dropped_attributes_count:
            size += len(b"X") + Varint.size_varint_u32(self.dropped_attributes_count)
        if self.original_payload_format:
            v = self.original_payload_format.encode("utf-8")
            size += len(b"b") + Varint.size_varint_u32(len(v)) + len(v)
        if self.original_payload:
            size += (
                len(b"j")
                + Varint.size_varint_u32(len(self.original_payload))
                + len(self.original_payload)
            )
        if self._attribute_indices:
            s = sum(Varint.size_varint_i32(int32) for int32 in self._attribute_indices)
            self.marshaler_cache[b"r"] = s
            size += len(b"r") + s + Varint.size_varint_u32(s)
        return size

    def write_to(self, out: bytearray) -> None:
        if self._sample_type:
            for v in self._sample_type:
                out += b"\n"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._sample:
            for v in self._sample:
                out += b"\x12"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self._location_indices:
            out += b"\x1a"
            Varint.write_varint_u32(out, self.marshaler_cache[b"\x1a"])
            for v in self._location_indices:
                Varint.write_varint_i32(out, v)
        if self.time_nanos:
            out += b" "
            Varint.write_varint_i64(out, self.time_nanos)
        if self.duration_nanos:
            out += b"("
            Varint.write_varint_i64(out, self.duration_nanos)
        if self._period_type is not None:
            out += b"2"
            Varint.write_varint_u32(out, self._period_type._get_size())
            self._period_type.write_to(out)
        if self.period:
            out += b"8"
            Varint.write_varint_i64(out, self.period)
        if self._comment_strindices:
            out += b"B"
            Varint.write_varint_u32(out, self.marshaler_cache[b"B"])
            for v in self._comment_strindices:
                Varint.write_varint_i32(out, v)
        if self.default_sample_type_index:
            out += b"H"
            Varint.write_varint_i32(out, self.default_sample_type_index)
        if self.profile_id:
            out += b"R"
            Varint.write_varint_u32(out, len(self.profile_id))
            out += self.profile_id
        if self.dropped_attributes_count:
            out += b"X"
            Varint.write_varint_u32(out, self.dropped_attributes_count)
        if self.original_payload_format:
            v = self.original_payload_format.encode("utf-8")
            out += b"b"
            Varint.write_varint_u32(out, len(v))
            out += v
        if self.original_payload:
            out += b"j"
            Varint.write_varint_u32(out, len(self.original_payload))
            out += self.original_payload
        if self._attribute_indices:
            out += b"r"
            Varint.write_varint_u32(out, self.marshaler_cache[b"r"])
            for v in self._attribute_indices:
                Varint.write_varint_i32(out, v)


class AttributeUnit(MessageMarshaler):
    attribute_key_strindex: int
    unit_strindex: int

    def __init__(
        self,
        attribute_key_strindex: int = 0,
        unit_strindex: int = 0,
    ):
        self.attribute_key_strindex: int = attribute_key_strindex
        self.unit_strindex: int = unit_strindex

    def calculate_size(self) -> int:
        size = 0
        if self.attribute_key_strindex:
            size += len(b"\x08") + Varint.size_varint_i32(self.attribute_key_strindex)
        if self.unit_strindex:
            size += len(b"\x10") + Varint.size_varint_i32(self.unit_strindex)
        return size

    def write_to(self, out: bytearray) -> None:
        if self.attribute_key_strindex:
            out += b"\x08"
            Varint.write_varint_i32(out, self.attribute_key_strindex)
        if self.unit_strindex:
            out += b"\x10"
            Varint.write_varint_i32(out, self.unit_strindex)


class Link(MessageMarshaler):
    trace_id: bytes
    span_id: bytes

    def __init__(
        self,
        trace_id: bytes = b"",
        span_id: bytes = b"",
    ):
        self.trace_id: bytes = trace_id
        self.span_id: bytes = span_id

    def calculate_size(self) -> int:
        size = 0
        if self.trace_id:
            size += (
                len(b"\n")
                + Varint.size_varint_u32(len(self.trace_id))
                + len(self.trace_id)
            )
        if self.span_id:
            size += (
                len(b"\x12")
                + Varint.size_varint_u32(len(self.span_id))
                + len(self.span_id)
            )
        return size

    def write_to(self, out: bytearray) -> None:
        if self.trace_id:
            out += b"\n"
            Varint.write_varint_u32(out, len(self.trace_id))
            out += self.trace_id
        if self.span_id:
            out += b"\x12"
            Varint.write_varint_u32(out, len(self.span_id))
            out += self.span_id


class ValueType(MessageMarshaler):
    type_strindex: int
    unit_strindex: int
    aggregation_temporality: AggregationTemporality

    def __init__(
        self,
        type_strindex: int = 0,
        unit_strindex: int = 0,
        aggregation_temporality: AggregationTemporality = 0,
    ):
        self.type_strindex: int = type_strindex
        self.unit_strindex: int = unit_strindex
        self.aggregation_temporality: AggregationTemporality = aggregation_temporality

    def calculate_size(self) -> int:
        size = 0
        if self.type_strindex:
            size += len(b"\x08") + Varint.size_varint_i32(self.type_strindex)
        if self.unit_strindex:
            size += len(b"\x10") + Varint.size_varint_i32(self.unit_strindex)
        if self.aggregation_temporality:
            v = self.aggregation_temporality
            if not isinstance(v, int):
                v = v.value
            size += len(b"\x18") + Varint.size_varint_u32(v)
        return size

    def write_to(self, out: bytearray) -> None:
        if self.type_strindex:
            out += b"\x08"
            Varint.write_varint_i32(out, self.type_strindex)
        if self.unit_strindex:
            out += b"\x10"
            Varint.write_varint_i32(out, self.unit_strindex)
        if self.aggregation_temporality:
            v = self.aggregation_temporality
            if not isinstance(v, int):
                v = v.value
            out += b"\x18"
            Varint.write_varint_u32(out, v)


class Sample(MessageMarshaler):
    locations_start_index: int
    locations_length: int

    @property
    def value(self) -> List[int]:
        if self._value is None:
            self._value = list()
        return self._value

    @property
    def attribute_indices(self) -> List[int]:
        if self._attribute_indices is None:
            self._attribute_indices = list()
        return self._attribute_indices

    link_index: int

    @property
    def timestamps_unix_nano(self) -> List[int]:
        if self._timestamps_unix_nano is None:
            self._timestamps_unix_nano = list()
        return self._timestamps_unix_nano

    def __init__(
        self,
        locations_start_index: int = 0,
        locations_length: int = 0,
        value: List[int] = None,
        attribute_indices: List[int] = None,
        link_index: int = None,
        timestamps_unix_nano: List[int] = None,
    ):
        self.locations_start_index: int = locations_start_index
        self.locations_length: int = locations_length
        self._value: List[int] = value
        self._attribute_indices: List[int] = attribute_indices
        self.link_index: int = link_index
        self._timestamps_unix_nano: List[int] = timestamps_unix_nano

    def calculate_size(self) -> int:
        size = 0
        if self.locations_start_index:
            size += len(b"\x08") + Varint.size_varint_i32(self.locations_start_index)
        if self.locations_length:
            size += len(b"\x10") + Varint.size_varint_i32(self.locations_length)
        if self._value:
            s = sum(Varint.size_varint_i64(int64) for int64 in self._value)
            self.marshaler_cache[b"\x1a"] = s
            size += len(b"\x1a") + s + Varint.size_varint_u32(s)
        if self._attribute_indices:
            s = sum(Varint.size_varint_i32(int32) for int32 in self._attribute_indices)
            self.marshaler_cache[b'"'] = s
            size += len(b'"') + s + Varint.size_varint_u32(s)
        if self.link_index is not None:
            size += len(b"(") + Varint.size_varint_i32(self.link_index)
        if self._timestamps_unix_nano:
            s = sum(
                Varint.size_varint_u64(uint64) for uint64 in self._timestamps_unix_nano
            )
            self.marshaler_cache[b"2"] = s
            size += len(b"2") + s + Varint.size_varint_u32(s)
        return size

    def write_to(self, out: bytearray) -> None:
        if self.locations_start_index:
            out += b"\x08"
            Varint.write_varint_i32(out, self.locations_start_index)
        if self.locations_length:
            out += b"\x10"
            Varint.write_varint_i32(out, self.locations_length)
        if self._value:
            out += b"\x1a"
            Varint.write_varint_u32(out, self.marshaler_cache[b"\x1a"])
            for v in self._value:
                Varint.write_varint_i64(out, v)
        if self._attribute_indices:
            out += b'"'
            Varint.write_varint_u32(out, self.marshaler_cache[b'"'])
            for v in self._attribute_indices:
                Varint.write_varint_i32(out, v)
        if self.link_index is not None:
            out += b"("
            Varint.write_varint_i32(out, self.link_index)
        if self._timestamps_unix_nano:
            out += b"2"
            Varint.write_varint_u32(out, self.marshaler_cache[b"2"])
            for v in self._timestamps_unix_nano:
                Varint.write_varint_u64(out, v)


class Mapping(MessageMarshaler):
    memory_start: int
    memory_limit: int
    file_offset: int
    filename_strindex: int

    @property
    def attribute_indices(self) -> List[int]:
        if self._attribute_indices is None:
            self._attribute_indices = list()
        return self._attribute_indices

    has_functions: bool
    has_filenames: bool
    has_line_numbers: bool
    has_inline_frames: bool

    def __init__(
        self,
        memory_start: int = 0,
        memory_limit: int = 0,
        file_offset: int = 0,
        filename_strindex: int = 0,
        attribute_indices: List[int] = None,
        has_functions: bool = False,
        has_filenames: bool = False,
        has_line_numbers: bool = False,
        has_inline_frames: bool = False,
    ):
        self.memory_start: int = memory_start
        self.memory_limit: int = memory_limit
        self.file_offset: int = file_offset
        self.filename_strindex: int = filename_strindex
        self._attribute_indices: List[int] = attribute_indices
        self.has_functions: bool = has_functions
        self.has_filenames: bool = has_filenames
        self.has_line_numbers: bool = has_line_numbers
        self.has_inline_frames: bool = has_inline_frames

    def calculate_size(self) -> int:
        size = 0
        if self.memory_start:
            size += len(b"\x08") + Varint.size_varint_u64(self.memory_start)
        if self.memory_limit:
            size += len(b"\x10") + Varint.size_varint_u64(self.memory_limit)
        if self.file_offset:
            size += len(b"\x18") + Varint.size_varint_u64(self.file_offset)
        if self.filename_strindex:
            size += len(b" ") + Varint.size_varint_i32(self.filename_strindex)
        if self._attribute_indices:
            s = sum(Varint.size_varint_i32(int32) for int32 in self._attribute_indices)
            self.marshaler_cache[b"*"] = s
            size += len(b"*") + s + Varint.size_varint_u32(s)
        if self.has_functions:
            size += len(b"0") + 1
        if self.has_filenames:
            size += len(b"8") + 1
        if self.has_line_numbers:
            size += len(b"@") + 1
        if self.has_inline_frames:
            size += len(b"H") + 1
        return size

    def write_to(self, out: bytearray) -> None:
        if self.memory_start:
            out += b"\x08"
            Varint.write_varint_u64(out, self.memory_start)
        if self.memory_limit:
            out += b"\x10"
            Varint.write_varint_u64(out, self.memory_limit)
        if self.file_offset:
            out += b"\x18"
            Varint.write_varint_u64(out, self.file_offset)
        if self.filename_strindex:
            out += b" "
            Varint.write_varint_i32(out, self.filename_strindex)
        if self._attribute_indices:
            out += b"*"
            Varint.write_varint_u32(out, self.marshaler_cache[b"*"])
            for v in self._attribute_indices:
                Varint.write_varint_i32(out, v)
        if self.has_functions:
            out += b"0"
            Varint.write_varint_u32(out, 1 if self.has_functions else 0)
        if self.has_filenames:
            out += b"8"
            Varint.write_varint_u32(out, 1 if self.has_filenames else 0)
        if self.has_line_numbers:
            out += b"@"
            Varint.write_varint_u32(out, 1 if self.has_line_numbers else 0)
        if self.has_inline_frames:
            out += b"H"
            Varint.write_varint_u32(out, 1 if self.has_inline_frames else 0)


class Location(MessageMarshaler):
    mapping_index: int
    address: int

    @property
    def line(self) -> List[Line]:
        if self._line is None:
            self._line = list()
        return self._line

    is_folded: bool

    @property
    def attribute_indices(self) -> List[int]:
        if self._attribute_indices is None:
            self._attribute_indices = list()
        return self._attribute_indices

    def __init__(
        self,
        mapping_index: int = None,
        address: int = 0,
        line: List[Line] = None,
        is_folded: bool = False,
        attribute_indices: List[int] = None,
    ):
        self.mapping_index: int = mapping_index
        self.address: int = address
        self._line: List[Line] = line
        self.is_folded: bool = is_folded
        self._attribute_indices: List[int] = attribute_indices

    def calculate_size(self) -> int:
        size = 0
        if self.mapping_index is not None:
            size += len(b"\x08") + Varint.size_varint_i32(self.mapping_index)
        if self.address:
            size += len(b"\x10") + Varint.size_varint_u64(self.address)
        if self._line:
            size += sum(
                message._get_size()
                + len(b"\x1a")
                + Varint.size_varint_u32(message._get_size())
                for message in self._line
            )
        if self.is_folded:
            size += len(b" ") + 1
        if self._attribute_indices:
            s = sum(Varint.size_varint_i32(int32) for int32 in self._attribute_indices)
            self.marshaler_cache[b"*"] = s
            size += len(b"*") + s + Varint.size_varint_u32(s)
        return size

    def write_to(self, out: bytearray) -> None:
        if self.mapping_index is not None:
            out += b"\x08"
            Varint.write_varint_i32(out, self.mapping_index)
        if self.address:
            out += b"\x10"
            Varint.write_varint_u64(out, self.address)
        if self._line:
            for v in self._line:
                out += b"\x1a"
                Varint.write_varint_u32(out, v._get_size())
                v.write_to(out)
        if self.is_folded:
            out += b" "
            Varint.write_varint_u32(out, 1 if self.is_folded else 0)
        if self._attribute_indices:
            out += b"*"
            Varint.write_varint_u32(out, self.marshaler_cache[b"*"])
            for v in self._attribute_indices:
                Varint.write_varint_i32(out, v)


class Line(MessageMarshaler):
    function_index: int
    line: int
    column: int

    def __init__(
        self,
        function_index: int = 0,
        line: int = 0,
        column: int = 0,
    ):
        self.function_index: int = function_index
        self.line: int = line
        self.column: int = column

    def calculate_size(self) -> int:
        size = 0
        if self.function_index:
            size += len(b"\x08") + Varint.size_varint_i32(self.function_index)
        if self.line:
            size += len(b"\x10") + Varint.size_varint_i64(self.line)
        if self.column:
            size += len(b"\x18") + Varint.size_varint_i64(self.column)
        return size

    def write_to(self, out: bytearray) -> None:
        if self.function_index:
            out += b"\x08"
            Varint.write_varint_i32(out, self.function_index)
        if self.line:
            out += b"\x10"
            Varint.write_varint_i64(out, self.line)
        if self.column:
            out += b"\x18"
            Varint.write_varint_i64(out, self.column)


class Function(MessageMarshaler):
    name_strindex: int
    system_name_strindex: int
    filename_strindex: int
    start_line: int

    def __init__(
        self,
        name_strindex: int = 0,
        system_name_strindex: int = 0,
        filename_strindex: int = 0,
        start_line: int = 0,
    ):
        self.name_strindex: int = name_strindex
        self.system_name_strindex: int = system_name_strindex
        self.filename_strindex: int = filename_strindex
        self.start_line: int = start_line

    def calculate_size(self) -> int:
        size = 0
        if self.name_strindex:
            size += len(b"\x08") + Varint.size_varint_i32(self.name_strindex)
        if self.system_name_strindex:
            size += len(b"\x10") + Varint.size_varint_i32(self.system_name_strindex)
        if self.filename_strindex:
            size += len(b"\x18") + Varint.size_varint_i32(self.filename_strindex)
        if self.start_line:
            size += len(b" ") + Varint.size_varint_i64(self.start_line)
        return size

    def write_to(self, out: bytearray) -> None:
        if self.name_strindex:
            out += b"\x08"
            Varint.write_varint_i32(out, self.name_strindex)
        if self.system_name_strindex:
            out += b"\x10"
            Varint.write_varint_i32(out, self.system_name_strindex)
        if self.filename_strindex:
            out += b"\x18"
            Varint.write_varint_i32(out, self.filename_strindex)
        if self.start_line:
            out += b" "
            Varint.write_varint_i64(out, self.start_line)
